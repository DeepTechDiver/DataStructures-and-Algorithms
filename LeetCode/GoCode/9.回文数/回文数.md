# 解题

**方法**： 通过反转一半的数字 与 剩余 原数字比较


**思路:**
- 第一种转换成字符串进行反转
  - 优点: 简单
  - 缺点: 需要额外的非常量空间
- 第二种对数字本身进行反正
  - 缺点: 反转后的数字大于ini.MAX造成整数溢出 

结合两种思路，可以通过反转一半的数字，得到的结果与剩余的一半进行比较

**算法：**

考虑一些临界问题：
> 1、很容易看出，负数不可能是回文数，

> 2、除负数意外 还有一些 个位数是 0 的数字，比如120 反转后是021，因为最高为不可能为0 所以也需要排除

正在的反转部分：

当输入的数字是回文数时，那么有两种情况 偶数个位数（1221） 和 奇数个位数（12121）

> 对于 1221 ：
> 1. 先通过对10取余（%10）得到 1 赋值给一个接收反转的结果的变量（revertedNumber ） 
> 2. 再通过除以10（/10）由于保留整数位的特性，1221 / 10 = 122 成功将1给移除 原数字剩余12
> 3. 再回到第一步操作 成功取到 倒数第二位数 2 ，那么得到的1 和 2 可以通过 每次 *10 得到 1 * 10 + 2 = 12 赋值给（revertedNumber）
> 4. 何时程序跳出循环？ （1）开始时：原始数字 > 反转数字，（2）程序不断运行，原始数字变小，反转数字变大，（3）当反转到一半时，此时 原始数字 = 反转数字，跳出循环。当原始数为12121这种奇数个位数时，原始数字 < 反转数字 即跳出循环 
> 5. 所以 原始数字 > 反转数字 为循环条件
> 
> 对于 12121：
> 1. 只需要在对 原始数字与反转数字进行相等判断的时候 对反转数据/10去除最后一位即中间位 再判断即可
>

**复杂度分析**

时间复杂度：O(log⁡n)O(\log n)O(logn)，对于每次迭代，我们会将输入除以 101010，因此时间复杂度为 O(log⁡n)O(\log n)O(logn)。

空间复杂度：O(1)O(1)O(1)。我们只需要常数空间存放若干变量。


**实例代码：**

```
func isPalindrome(x int) bool {
    // 特殊情况：
    // 如上所述，当 x < 0 时，x 不是回文数。
    // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
    // 则其第一位数字也应该是 0
    // 只有 0 满足这一属性
    if x < 0 || (x % 10 == 0 && x != 0) {
        return false
    }

    revertedNumber := 0
    for x > revertedNumber {
        revertedNumber = revertedNumber * 10 + x % 10
        x /= 10
    }

    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
    return x == revertedNumber || x == revertedNumber / 10
}
```